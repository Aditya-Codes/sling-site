
<!DOCTYPE HTML PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<HTML>
  <HEAD>
    <TITLE>Apache Sling - Sling API Redesign</TITLE>
    <LINK rel="stylesheet" href="http://incubator.apache.org/sling/site/media.data/site.css" type="text/css" media="all">
    <LINK rel="icon" href="http://incubator.apache.org/sling/site/media.data/favicon.ico">
    <META http-equiv="Content-Type" content="text/html;charset=UTF-8">
  </HEAD>
  <BODY><div class="siteconversion">This is an old version of the Sling website, see the <a href="http://sling.apache.org/site-conversion.html">site conversion page</a> for more info.</div>
    <DIV class="title">
      <DIV class="logo">
        <A href="http://incubator.apache.org/sling/site/index.html">
          <IMG border="0" alt="Apache Sling" src="http://incubator.apache.org/sling/site/media.data/logo.png">
        </A>
      </DIV>
      <DIV class="header">
        <A href="http://incubator.apache.org/">
          <IMG border="0" alt="Apache Incubator" src="http://incubator.apache.org/images/apache-incubator-logo.png">
        </A>
      </DIV>
    </DIV>
    <DIV class="menu">
                                    <P>

<UL>
	<LI><A href="index.html" title="Index">Home</A></LI>
	<LI><A href="project-information.html" title="Project Information">Project Information</A></LI>
	<LI><A href="usecases.html" title="UseCases">Use Cases</A></LI>
	<LI><A href="guides.html" title="Guides">Guides</A></LI>
	<LI><A href="documentation.html" title="Documentation">Documentation</A></LI>
	<LI><A href="plugins.html" title="Plugins">Plugins</A></LI>
	<LI><A href="faq.html" title="FAQ">FAQ</A></LI>
	<LI><A href="links.html" title="Links">Links</A></LI>
	<LI><A href="old-documentation.html" title="Old Documentation">Old Documentation</A></LI>
	<LI><SPAN class="nobr"><A href="http://cwiki.apache.org/confluence/x/GAUB" title="Visit page outside Confluence" rel="nofollow">Wiki<SUP><IMG class="rendericon" src="http://cwiki.apache.org/confluence/images/icons/linkext7.gif" height="7" width="7" align="absmiddle" alt="" border="0"></SUP></A></SPAN></LI>
	<LI><SPAN class="nobr"><A href="http://www.apache.org/foundation/thanks.html" title="Visit page outside Confluence" rel="nofollow">Sponsors<SUP><IMG class="rendericon" src="http://cwiki.apache.org/confluence/images/icons/linkext7.gif" height="7" width="7" align="absmiddle" alt="" border="0"></SUP></A></SPAN></LI>
	<LI><SPAN class="nobr"><A href="http://www.apache.org/foundation/sponsorship.html" title="Visit page outside Confluence" rel="nofollow">Sponsorship<SUP><IMG class="rendericon" src="http://cwiki.apache.org/confluence/images/icons/linkext7.gif" height="7" width="7" align="absmiddle" alt="" border="0"></SUP></A></SPAN></LI>
</UL>


<P>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            </DIV>
    <DIV class="main">
<H1><A name="SlingAPIRedesign-RedesignoftheSlingAPI"></A>Redesign of the Sling API</H1>

<P>There have been a number of threads on the Sling Dev Mailing List on simplifying the current <EM>Component API</EM> and turn it into a new Sling API. This page starts at the current state of the discussion as of Oct. 10, 2007, and tries to summarize what has been discussed and to resolve this into a modified proposal.</P>

<DIV>[ <A href="#SlingAPIRedesign-RedesignoftheSlingAPI">Redesign of the Sling API</A> ] [ <A href="#SlingAPIRedesign-References">References</A> ] [ <A href="#SlingAPIRedesign-CurrentState">Current State</A> ] [ <A href="#SlingAPIRedesign-UpdateModified%257B%257BContent%257D%257D">Update Modified <TT>Content</TT></A> ] [ <A href="#SlingAPIRedesign-JCRbasedOperations">JCR based Operations</A> ] [ <A href="#SlingAPIRedesign-Replace%257B%257BContent%257D%257Dby%257B%257BResource%257D%257D">Replace <TT>Content</TT> by <TT>Resource</TT></A> ] [ <A href="#SlingAPIRedesign-Extensionstothe%257B%257BResource%257D%257Dinterface">Extensions to the <TT>Resource</TT> interface</A> ] [ <A href="#SlingAPIRedesign-OpenIssues">Open Issues</A> ] [ <A href="#SlingAPIRedesign-ResolvingtheServlet">Resolving the Servlet</A> ]</DIV>


<H2><A name="SlingAPIRedesign-References"></A>References</H2>

<UL>
	<LI><SPAN class="nobr"><A href="http://issues.apache.org/jira/browse/SLING-28" title="Visit page outside Confluence" rel="nofollow">SLING-28, Simplify the Sling (aka Component) API<SUP><IMG class="rendericon" src="http://cwiki.apache.org/confluence/images/icons/linkext7.gif" height="7" width="7" align="absmiddle" alt="" border="0"></SUP></A></SPAN></LI>
	<LI><SPAN class="nobr"><A href="http://issues.apache.org/jira/browse/SLING-47" title="Visit page outside Confluence" rel="nofollow">SLING-47, microsling<SUP><IMG class="rendericon" src="http://cwiki.apache.org/confluence/images/icons/linkext7.gif" height="7" width="7" align="absmiddle" alt="" border="0"></SUP></A></SPAN>, &quot;Sling reduced to the max&quot;</LI>
	<LI><SPAN class="nobr"><A href="http://www.mail-archive.com/sling-dev@incubator.apache.org/msg00177.html" title="Visit page outside Confluence" rel="nofollow">Simplifying our component api<SUP><IMG class="rendericon" src="http://cwiki.apache.org/confluence/images/icons/linkext7.gif" height="7" width="7" align="absmiddle" alt="" border="0"></SUP></A></SPAN> - The original thread launched by Carsten</LI>
	<LI><SPAN class="nobr"><A href="http://www.mail-archive.com/sling-dev@incubator.apache.org/msg00267.html" title="Visit page outside Confluence" rel="nofollow">Move ContentManager to Sling API<SUP><IMG class="rendericon" src="http://cwiki.apache.org/confluence/images/icons/linkext7.gif" height="7" width="7" align="absmiddle" alt="" border="0"></SUP></A></SPAN> - My own proposal to make the ContentManager part of the Sling API</LI>
	<LI><SPAN class="nobr"><A href="http://www.mail-archive.com/sling-dev@incubator.apache.org/msg00288.html" title="Visit page outside Confluence" rel="nofollow">Breaking Sling into smaller pieces?<SUP><IMG class="rendericon" src="http://cwiki.apache.org/confluence/images/icons/linkext7.gif" height="7" width="7" align="absmiddle" alt="" border="0"></SUP></A></SPAN> - Bertrand's proposal to further modularize parts of Sling such as the current <EM>sling-core</EM> bundle</LI>
</UL>




<H2><A name="SlingAPIRedesign-CurrentState"></A>Current State</H2>

<P>Currently, request processing is controlled by the <EM>sling-core</EM> bundle using two sets of filters: one set called at the time the client request enters Sling - so called request level filters - and the other set called for each Content object processed during request processing - so called content level filters.</P>

<P>Amongst the request level filters is the <TT>ContentResolverFilter</TT> which takes the request URL and finds a <TT>Content</TT> object for the URL. This filter implements the <TT>ContentResolver</TT> interface and is also registered as this service. So other parts of the system may use the same mechanism to resolve paths to <TT>Content</TT> objects. The <TT>ContentResolver</TT> also implements the default content loading described <A href="default-mapping-and-rendering.html" title="Default Mapping and Rendering">here</A>.</P>

<P>Amongst the content level filters is the <TT>ComponentResolverFilter</TT> which asks the <TT>Content</TT> object for its component ID and resolves this ID using the registered {{Component}}s. This filter also implements the default component resolution described <A href="default-mapping-and-rendering.html" title="Default Mapping and Rendering">here</A>.</P>

<P>To manage content Sling provides two interfaces:</P>

<UL>
	<LI><B><TT>ContentManager</TT></B> - Basic interface allowing CRUD operations using <TT>Content</TT> objects. This interface is completely agnostic of the actual persistence used.</LI>
	<LI><B><TT>JcrContentManager</TT></B> - Extends the <TT>ContentManager</TT> interface integrating with the Jackrabbit OCM <TT>ObjectContentManager</TT> interface. This provides the API actually used by the <TT>ContentResolverFilter</TT> to load <TT>Content</TT> objects from the JCR repository according to the request URL.</LI>
</UL>



<P>If components would want to create, update and delete content, they would access the <TT>ContentManager</TT> by retrieving the <TT>org.apache.sling.jcr.content_manager</TT> request attribute. If JCR tasks would have to be executed, that retrieved object would be cast to <TT>JcrContentManager</TT> and the session retrieved.</P>

<P>Examples:</P>

<H5><A name="SlingAPIRedesign-UpdateModified%7B%7BContent%7D%7D"></A>Update Modified <TT>Content</TT></H5>

<P>After having modified the content, a component might do the following to persisted the modified content:</P>

<DIV class="code"><DIV class="codeContent">
<PRE class="code-java">Content content = componentRequest.getContent();

<SPAN class="code-comment">// modify content
</SPAN>
ContentManager contentManager = (ContentManager) componentRequest.getAttribute(<SPAN class="code-quote">&quot;org.apache.sling.jcr.content_manager&quot;</SPAN>);
contentManager.store(content);
contentManager.save();</PRE>
</DIV></DIV>


<H5><A name="SlingAPIRedesign-JCRbasedOperations"></A>JCR based Operations</H5>

<P>To operate on a JCR level or to directly access the JCR <TT>Node</TT> underlying the request <TT>Content</TT> the following might be done:</P>

<DIV class="code"><DIV class="codeContent">
<PRE class="code-java"><SPAN class="code-comment">// get the JCR content manager
</SPAN>JcrContentManager jcrContentManager = (JcrContentManager) componentRequest.getAttribute(<SPAN class="code-quote">&quot;org.apache.sling.jcr.content_manager&quot;</SPAN>);

<SPAN class="code-comment">// get the session
</SPAN>Session session = jcrContentManager.getSession();

<SPAN class="code-comment">// access the node addressed by the request URL
</SPAN><SPAN class="code-object">String</SPAN> contentPath = componentRequest.getContent().getPath();
Node contentNode = (Node) session.getItem(contentPath);</PRE>
</DIV></DIV>


<P>Arguably, this is tedious. So a first simplification proposal suggested to move the JCR agnostic <TT>ContentManager</TT> interface to the Sling API and to provide a getter method on the <TT>ComponentRequest</TT> interface. The returned object might also be cast to a <TT>JcrContentManager</TT> to then access the repository.</P>

<P>This proposal sparked a series of reactions (see references above) and so based on Bertrands thoughts, we propose the following change.</P>



<H2><A name="SlingAPIRedesign-Replace%7B%7BContent%7D%7Dby%7B%7BResource%7D%7D"></A>Replace <TT>Content</TT> by <TT>Resource</TT></H2>

<P>The &quot;problem&quot; of the current Component API is that is centered around a <TT>Content</TT> interface which presumably is data provided to the component loaded from the persistence (the JCR repository of course) actually hiding the repository. This also predefines how data is acquired and used, namely by using Object Content Mapping.</P>

<P>Starting off this situation, we propose replacing the (fully loaded) <TT>Content</TT> by a data representation we will call <TT>Resource</TT>:</P>

<DIV class="code"><DIV class="codeContent">
<PRE class="code-java"><SPAN class="code-keyword">public</SPAN> <SPAN class="code-keyword">interface</SPAN> Resource {

  <SPAN class="code-comment">// the original request URL leading to the resource
</SPAN>  <SPAN class="code-comment">// <SPAN class="code-keyword">this</SPAN> is not necessairily the same as ServletRequest.getRequestURL as
</SPAN>  <SPAN class="code-comment">// it may have been processed by some URL mapping and folding
</SPAN>  <SPAN class="code-object">String</SPAN> getOriginalURI();

  <SPAN class="code-comment">// the path to the actual resource providing the data
</SPAN>  <SPAN class="code-comment">// from the point of view of Sling <SPAN class="code-keyword">this</SPAN> is just a string
</SPAN>  <SPAN class="code-object">String</SPAN> getURI();

  <SPAN class="code-comment">// the selectors of the request or empty array <SPAN class="code-keyword">if</SPAN> none
</SPAN>  <SPAN class="code-comment">// the selectors are dot-separated strings after the part of
</SPAN>  <SPAN class="code-comment">// original URI addressing the resource upto the extension
</SPAN>  <SPAN class="code-comment">// Examples:
</SPAN>  <SPAN class="code-comment">//    - /a/b/c has no selectors <SPAN class="code-keyword">for</SPAN> resource /a/b/c
</SPAN>  <SPAN class="code-comment">//    - /a/b/c.html has no selectors <SPAN class="code-keyword">for</SPAN> resource /a/b/c
</SPAN>  <SPAN class="code-comment">//    - /a/b/c.s1.s2.html has selectors [ s1, s2 ] <SPAN class="code-keyword">for</SPAN> resource /a/b/c
</SPAN>  <SPAN class="code-comment">//    - /a/b/c.s.html/suffix has selector [ s ] <SPAN class="code-keyword">for</SPAN> resource /a/b/c
</SPAN>  <SPAN class="code-object">String</SPAN>[] getSelectors();

  <SPAN class="code-comment">// the extension of the request or empty string <SPAN class="code-keyword">if</SPAN> none
</SPAN>  <SPAN class="code-comment">// the extension is a string after the last dot after the
</SPAN>  <SPAN class="code-comment">// part of the original URI addressing the resource upto the
</SPAN>  <SPAN class="code-comment">// end of the original URI or a slash
</SPAN>  <SPAN class="code-comment">// Examples:
</SPAN>  <SPAN class="code-comment">//    - /a/b/c has no extension <SPAN class="code-keyword">for</SPAN> resource /a/b/c
</SPAN>  <SPAN class="code-comment">//    - /a/b/c.html has extension html <SPAN class="code-keyword">for</SPAN> resource /a/b/c
</SPAN>  <SPAN class="code-comment">//    - /a/b/c.s1.s2.html has extension html <SPAN class="code-keyword">for</SPAN> resource /a/b/c
</SPAN>  <SPAN class="code-comment">//    - /a/b/c.s.html/suffix has extension html <SPAN class="code-keyword">for</SPAN> resource /a/b/c
</SPAN>  <SPAN class="code-object">String</SPAN> getExtension();

  <SPAN class="code-comment">// the suffix of the request or empty string <SPAN class="code-keyword">if</SPAN> none
</SPAN>  <SPAN class="code-comment">// the suffix is the string after the next slash after the part
</SPAN>  <SPAN class="code-comment">// of the original URI addressing the resource
</SPAN>  <SPAN class="code-comment">// Examples:
</SPAN>  <SPAN class="code-comment">//    - /a/b/c has no suffix <SPAN class="code-keyword">for</SPAN> resource /a/b/c
</SPAN>  <SPAN class="code-comment">//    - /a/b/c.html has no suffix <SPAN class="code-keyword">for</SPAN> resource /a/b/c
</SPAN>  <SPAN class="code-comment">//    - /a/b/c.s1.s2.html has no suffix <SPAN class="code-keyword">for</SPAN> resource /a/b/c
</SPAN>  <SPAN class="code-comment">//    - /a/b/c.s.html/suffix has suffix suffix <SPAN class="code-keyword">for</SPAN> resource /a/b/c
</SPAN>  <SPAN class="code-object">String</SPAN> getSuffix();

}</PRE>
</DIV></DIV>

<P>The <TT>ComponentRequest</TT> interface would be modified as follows:</P>

<UL>
	<LI>The <TT>getExtension()</TT>, <TT>getSelector(int)</TT>, <TT>getSelectors()</TT>, <TT>getSelectorString()</TT> and <TT>getSuffix()</TT> methods are removed as this information can now be obtained from the <TT>Resource</TT> directly.</LI>
	<LI>The <TT>getContent()</TT>, <TT>getContent(String)</TT>, <TT>getChildren(Content)</TT> and <TT>getRequestDispatcher(Content)</TT> methods are replaced as follows:</LI>
</UL>


<DIV class="code"><DIV class="codeContent">
<PRE class="code-java"><SPAN class="code-keyword">public</SPAN> <SPAN class="code-keyword">interface</SPAN> ComponentRequest <SPAN class="code-keyword">extends</SPAN> HttpServletRequest {

  ...

  <SPAN class="code-comment">// Returns the Resource to which the getRequestURL method maps
</SPAN>  Resource getResource();

  <SPAN class="code-comment">// Returns a Resource to which the given URI <SPAN class="code-object">String</SPAN> maps
</SPAN>  <SPAN class="code-comment">// Implicit: getResource().equals(getResource(getRequestURL()))
</SPAN>  Resource getResource(<SPAN class="code-object">String</SPAN> uri);

  <SPAN class="code-comment">// Returns an Enumeration child Resources of the given Resource
</SPAN>  <SPAN class="code-comment">// If resource parameter is <SPAN class="code-keyword">null</SPAN>, getResource() is used as parent
</SPAN>  <SPAN class="code-comment">// (use Enumeration to stay in line with the HttpServletRequest)
</SPAN>  Enumeration&lt;Resource&gt; getChildren(Resource resource);

  <SPAN class="code-comment">// Gets a RequestDispatcher to include the given resource
</SPAN>  RequestDispatcher getRequestDispatcher(Resource resource);

  ...

}</PRE>
</DIV></DIV>


<H3><A name="SlingAPIRedesign-Extensionstothe%7B%7BResource%7D%7Dinterface"></A>Extensions to the <TT>Resource</TT> interface</H3>

<P>The <TT>Resource</TT> interface may be extended depending on the way, the resource is acquired. For example, there might be a <TT>MappedContentResource</TT> which would return an object mapped from any persistence layer, a <TT>JcrResource</TT> may encapsulate a JCR based resource. A resolver loading content from a JCR repository using Jackrabbit OCM might return a resource which implements both the <TT>MappedContentResource</TT> and the <TT>JcrResource</TT> interfaces.</P>

<DIV class="code"><DIV class="codeHeader"><B>MappedContentResource</B></DIV><DIV class="codeContent">
<PRE class="code-java"><SPAN class="code-keyword">public</SPAN> <SPAN class="code-keyword">interface</SPAN> MappedContentResource <SPAN class="code-keyword">extends</SPAN> Resource {

  <SPAN class="code-comment">// Returns the mapped data object
</SPAN>  <SPAN class="code-object">Object</SPAN> getObject();

}</PRE>
</DIV></DIV>

<DIV class="code"><DIV class="codeHeader"><B>JcrResource</B></DIV><DIV class="codeContent">
<PRE class="code-java"><SPAN class="code-keyword">public</SPAN> <SPAN class="code-keyword">interface</SPAN> JcrResource <SPAN class="code-keyword">extends</SPAN> Resource {

  <SPAN class="code-comment">// Returns the JCR session used to acquire the Node
</SPAN>  <SPAN class="code-comment">// (<SPAN class="code-keyword">this</SPAN> is actually convenience as getNode().getSession()
</SPAN>  <SPAN class="code-comment">// must <SPAN class="code-keyword">return</SPAN> the same session)
</SPAN>  Session getSession();

  <SPAN class="code-comment">// Returns the JCR Node addressed by the Resource URI
</SPAN>  <SPAN class="code-comment">// <SPAN class="code-keyword">this</SPAN> is the same as getSession().getItem(getURI());
</SPAN>  Node getNode();

}</PRE>
</DIV></DIV>


<P>The existing ContentResolver will be retargeted to the <TT>Resource</TT> interface and return an object implementing the <TT>MappedContentResource</TT> and the <TT>JcrResource</TT> interfaces if a mapping exists. Otherwise an object just implementing the <TT>JcrResource</TT> interface is returned providing just the resolved node.</P>


<H2><A name="SlingAPIRedesign-OpenIssues"></A>Open Issues</H2>

<P>This above definition leaves a series of issues open.</P>


<H3><A name="SlingAPIRedesign-ResolvingtheServlet"></A>Resolving the Servlet</H3>

<TABLE cellpadding="5" width="85%" cellspacing="8px" class="infoMacro" border="0" align="center"><COLGROUP><COL width="24"><COL></COLGROUP><TR><TD valign="top"><IMG src="http://cwiki.apache.org/confluence/images/icons/emoticons/information.gif" width="16" height="16" align="absmiddle" alt="" border="0"></TD><TD>
<P>The <TT>Component</TT> interface is removed and the <TT>Servlet</TT> interface is used.</P></TD></TR></TABLE>

<P>Currently the <TT>Content</TT> interface defines a method <TT>getComponentId()</TT> which returns the identifier of a <TT>Component</TT> to which processing of the request is dispatched. With the new <TT>Resource</TT> interface, no such method exists any more.</P>

<P>The intent is, that <TT>Servlet</TT> resolver would know about the concrete implementations of the <TT>Resource</TT> interface and could handle the respective resources. For example the Sling standard servlet resolver could try the following:</P>

<OL>
	<LI>If the <TT>Resource</TT> is a <TT>JcrResource</TT> check the <TT>sling:servletId</TT> property of the resource node. If such a property exists and denotes a registered <TT>Servlet</TT> service, that servlet is used.</LI>
	<LI>Otherwise, if the <TT>Resource</TT> is a <TT>MappedContentResource</TT>, find a <TT>Servlet</TT> service willing to handle requests for the actual object class of the mapped object. The <TT>Servlet</TT> service could be registered with a service property listing the names of the mapped object classes supported.</LI>
	<LI>Otherwise try to find a registered <TT>Servlet</TT> interface willing to handle the request using the resource path, selectors and/or extensions.</LI>
</OL>


<P>Alternatively, the <TT>Resource</TT> interface might have a <TT>getServletId()</TT> method providing the identifier of the servlet to use. It might well be that the first solution is the better one.</P>
    </DIV>
  </BODY>
</HTML>

